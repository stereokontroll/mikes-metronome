<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <title>Mike's Metronome</title>

    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1e1e1e">
    
    <link rel="stylesheet" href="style.css">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%231e1e1e'/%3E%3Cpath d='M50 25 L25 90 L75 90 Z' fill='%23666666'/%3E%3Cline x1='50' y1='90' x2='50' y2='15' stroke='%23aaaaaa' stroke-width='4'/%3E%3Ccircle cx='50' cy='35' r='8' fill='%2303dac6'/%3E%3Ctext x='50' y='85' font-family='Arial Black, sans-serif' font-size='35' font-weight='900' fill='%2303dac6' text-anchor='middle'%3EM%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%231e1e1e'/%3E%3Cpath d='M50 25 L25 90 L75 90 Z' fill='%23666666'/%3E%3Cline x1='50' y1='90' x2='50' y2='15' stroke='%23aaaaaa' stroke-width='4'/%3E%3Ccircle cx='50' cy='35' r='8' fill='%2303dac6'/%3E%3Ctext x='50' y='85' font-family='Arial Black, sans-serif' font-size='35' font-weight='900' fill='%2303dac6' text-anchor='middle'%3EM%3C/text%3E%3C/svg%3E">
</head>
<body>

    <div class="header-bar">
        <button class="hamburger-btn" onclick="toggleMenu()">&#9776;</button>
    </div>

    <div class="menu-overlay" id="menuOverlay" onclick="toggleMenu()"></div>
    <div class="menu-drawer" id="menuDrawer">
        <button class="close-menu-btn" onclick="toggleMenu()">√ó</button>
        <div class="menu-header">Menu</div>
        
        <button class="accordion-btn">üíæ Saved Songs</button>
        <div class="accordion-panel">
            <div id="savedSongsList">
                <p style="font-size: 12px; color:#888; text-align:center; padding: 10px 0;">No songs saved yet</p>
            </div>
        </div>

        <button class="accordion-btn">üîä Sound</button>
        <div class="accordion-panel">
            <label class="sound-option">
                <input type="radio" name="soundType" value="high" onclick="setSoundType('high')">
                <span>Sharp (Default)</span>
            </label>
            <label class="sound-option">
                <input type="radio" name="soundType" value="wood" onclick="setSoundType('wood')">
                <span>Wood (Click)</span>
            </label>
            <label class="sound-option">
                <input type="radio" name="soundType" value="soft" onclick="setSoundType('soft')">
                <span>Soft (Sine)</span>
            </label>
        </div>

        <button class="accordion-btn">üëã About</button>
        <div class="accordion-panel">
            <p class="menu-text">
                Hi, I'm Mike!<br>I'm a drummer myself.<br>I originally built this app to help my son practice for his trumpet exam, but I decided to share it with the world.
                <br><br>
                Enjoy practicing!
            </p>
        </div>

        <div class="menu-section" style="margin-top: 20px;">
            <h3>Support</h3>
            <p class="menu-text">Do you like this app? Consider supporting the development.</p>
            <a href="https://www.buymeacoffee.com/mikesmetronome" target="_blank" class="coffee-btn">
                ‚òï Buy me a coffee
            </a>
        </div>
        
        <div class="version-text" id="appVersion"></div>
    </div>


    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('basic')">Basic</button>
        <button class="tab-btn" onclick="switchTab('advanced')">Advanced</button>
    </div>

    <div class="status-display" id="advStatus" style="display:none;">
        <div class="status-text" id="advStepName">Step 1</div>
        <div class="huge-counter" id="advBarCount">Bar 1</div>
    </div>

    <div id="panel-basic" class="panel active">
        <div class="controls">
            <h1>Mike's Metronome</h1>
            <div class="row">
                <div style="width: 45%;">
                    <label>Tempo</label>
                    <input type="number" id="bpm" value="100" min="30" max="300" onchange="saveBasicSettings()">
                </div>
                <div style="width: 48%;">
                    <label>Time Signature</label>
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <input type="number" id="beatCountInput" value="4" min="1" max="16" style="width: 45%;" onchange="updateBasicDots(this.value); saveBasicSettings()">
                        <span style="font-size: 20px; color:#666;">/</span>
                        <select id="beatValueInput" style="width: 45%;" onchange="saveBasicSettings()">
                            <option value="2">2</option>
                            <option value="4" selected>4</option>
                            <option value="8">8</option>
                        </select>
                    </div>
                </div>
            </div>
            <p style="font-size:11px; color:#666;">Tap dots for accents</p>
            <div class="beat-visualizer" id="beatContainer"></div>
        </div>
    </div>

    <div id="panel-advanced" class="panel">
        
        <div class="step-list">
            <div class="count-in-box" id="countInBox">
                <div class="count-in-header">
                    <label class="count-in-toggle">
                        <input type="checkbox" id="countInCheck" onchange="toggleCountIn()">
                        Start with Count-in
                    </label>
                </div>
                <div id="countInControls" style="display:block;">
                    <div class="step-inputs">
                        <div class="step-input-group">
                            <label>BPM</label>
                            <input type="number" id="ciBpm" onchange="saveCountIn()">
                        </div>
                        <div class="step-input-group">
                            <label>Sig.</label>
                            <div style="display:flex; gap:2px;">
                                <input type="number" id="ciBeats" onchange="updateCountInDots(); saveCountIn()">
                                <select id="ciValue" onchange="saveCountIn()">
                                    <option value="4">/4</option>
                                    <option value="8">/8</option>
                                    <option value="2">/2</option>
                                </select>
                            </div>
                        </div>
                        <div class="step-input-group">
                            <label>Bars</label>
                            <input type="number" id="ciBars" onchange="saveCountIn()">
                        </div>
                    </div>
                    <label style="font-size:10px; color:#666;">Count-in Accents:</label>
                    <div class="step-accents" id="ciAccentsContainer"></div>
                </div>
            </div>
        </div>

        <div class="step-list" id="stepListContainer"></div>
        
        <div class="step-list">
            <button class="add-btn" onclick="addStep()">+ Add Step</button>
            
            <div class="action-btn-container">
                <button class="secondary-btn btn-reset" onclick="resetSequence()">
                    üóëÔ∏è New
                </button>
                <button class="secondary-btn btn-save" onclick="saveCurrentSequence()">
                    üíæ Save
                </button>
            </div>
        </div>

        <div class="repeat-wrapper">
            <input type="checkbox" id="repeatCheckbox" onchange="saveRepeatSetting()">
            <label for="repeatCheckbox">Loop Sequence</label>
        </div>
        <p style="font-size:11px; color:#666; margin-top:5px; text-align:center;">
            (Count-in is skipped during loop)
        </p>
    </div>

    <div class="main-btn-container">
        <button id="mainActionBtn">START</button>
    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let currentMode = 'basic'; 
        let isRunning = false;
        let audioContext = null;
        let timerID = null;
        let nextNoteTime = 0.0;
        
        // Wake Lock Variable
        let wakeLock = null;

        // Sound Settings
        let currentSoundType = 'high'; // high, wood, soft

        // Basic Mode State
        let currentBeatIndex = 0;
        let basicAccents = []; 

        // Advanced Mode State
        let sequence = [];
        let countInSettings = { enabled: false, bpm: 100, beats: 4, value: 4, bars: 1, accents: [2,0,0,0] };
        let isRepeatEnabled = false;
        
        // Saved Songs
        let savedSequences = [];

        // Loop Variables
        let playPhase = 0; // 0 = CountIn, 1 = Sequence
        let currentStepIndex = 0; 
        let advBarCounter = 1; 
        let advBeatCounter = 0; 

        // --- DOM ELEMENTS ---
        const mainBtn = document.getElementById('mainActionBtn');
        const basicPanel = document.getElementById('panel-basic');
        const advPanel = document.getElementById('panel-advanced');
        
        // Menu Elements
        const menuDrawer = document.getElementById('menuDrawer');
        const menuOverlay = document.getElementById('menuOverlay');
        const savedSongsList = document.getElementById('savedSongsList');

        // Status Displays
        const advStatus = document.getElementById('advStatus');
        const advStepName = document.getElementById('advStepName');
        const advBarCountEl = document.getElementById('advBarCount');
        
        // Inputs Basic
        const bpmInput = document.getElementById('bpm');
        const beatCountInput = document.getElementById('beatCountInput');
        const beatValueInput = document.getElementById('beatValueInput');
        const beatContainer = document.getElementById('beatContainer');
        const repeatCheckbox = document.getElementById('repeatCheckbox');
        
        // Inputs Count-in
        const countInBox = document.getElementById('countInBox');
        const countInCheck = document.getElementById('countInCheck');
        const ciBpm = document.getElementById('ciBpm');
        const ciBeats = document.getElementById('ciBeats');
        const ciValue = document.getElementById('ciValue');
        const ciBars = document.getElementById('ciBars');
        const ciAccentsContainer = document.getElementById('ciAccentsContainer');

        // --- INITIALIZATION ---
        loadSettings(); 
        initAccordionMenu();
        loadVersionFromSW(); 
        
        // DEFAULT STATE
        if(sequence.length === 0) {
            sequence = [
                { name: "", bpm: 100, beats: 4, value: 4, bars: 4, accents: [2,0,0,0] }
            ];
        }
        
        updateBasicDots(parseInt(beatCountInput.value));
        const savedBasicAccents = localStorage.getItem('mikeMetronomeBasicAccents');
        if(savedBasicAccents) {
            basicAccents = JSON.parse(savedBasicAccents);
            renderBasicDotsUI(); 
        }

        initCountInUI();
        renderStepList();
        renderSavedSongsMenu();

        // --- SOUND SETTINGS LOGIC ---
        function setSoundType(type) {
            currentSoundType = type;
            localStorage.setItem('mikeMetronomeSoundType', type);
            // Optioneel: speel een testgeluidje af bij klikken
            if(audioContext && audioContext.state === 'running' && !isRunning) {
                // Short preview click (Mid accent freq)
                playSound(1000, audioContext.currentTime);
            }
        }

        // --- WAKE LOCK FUNCTIONS ---
        async function requestWakeLock() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                } catch (err) {
                    console.error(`${err.name}, ${err.message}`);
                }
            }
        }

        function releaseWakeLock() {
            if (wakeLock !== null) {
                wakeLock.release().then(() => { wakeLock = null; });
            }
        }

        // --- MENU LOGIC ---
        function toggleMenu() {
            const isOpen = menuDrawer.classList.contains('open');
            if (isOpen) {
                menuDrawer.classList.remove('open');
                menuOverlay.classList.remove('open');
                setTimeout(() => menuOverlay.style.display = 'none', 300);
            } else {
                menuOverlay.style.display = 'block';
                setTimeout(() => {
                    menuDrawer.classList.add('open');
                    menuOverlay.classList.add('open');
                }, 10);
            }
        }
        
        // --- ACCORDION LOGIC ---
        function initAccordionMenu() {
            const acc = document.getElementsByClassName("accordion-btn");
            for (let i = 0; i < acc.length; i++) {
                acc[i].addEventListener("click", function() {
                    this.classList.toggle("active");
                    const panel = this.nextElementSibling;
                    if (panel.style.maxHeight) {
                        panel.style.maxHeight = null;
                    } else {
                        panel.style.maxHeight = panel.scrollHeight + "px";
                    } 
                });
            }
        }
        
        // --- VERSION FETCH LOGIC ---
        async function loadVersionFromSW() {
            try {
                const response = await fetch('./sw.js?t=' + Date.now());
                const text = await response.text();
                const match = text.match(/CACHE_NAME\s*=\s*["']([^"']+)["']/);
                if (match && match[1]) {
                    const v = match[1].replace('metronome-', '');
                    document.getElementById('appVersion').textContent = `${v}`;
                }
            } catch (e) {
                console.log("Could not fetch version");
            }
        }

        // --- LOCAL STORAGE ---
        function saveBasicSettings() {
            localStorage.setItem('mikeMetronomeBasicBpm', bpmInput.value);
            localStorage.setItem('mikeMetronomeBasicCount', beatCountInput.value);
            localStorage.setItem('mikeMetronomeBasicValue', beatValueInput.value);
            localStorage.setItem('mikeMetronomeBasicAccents', JSON.stringify(basicAccents));
        }

        function saveSequence() {
            localStorage.setItem('mikeMetronomeSequence', JSON.stringify(sequence));
        }

        function saveCountIn() {
            countInSettings.enabled = countInCheck.checked;
            countInSettings.bpm = parseInt(ciBpm.value);
            countInSettings.beats = parseInt(ciBeats.value);
            countInSettings.value = parseInt(ciValue.value);
            countInSettings.bars = parseInt(ciBars.value);
            localStorage.setItem('mikeMetronomeCountIn', JSON.stringify(countInSettings));
            updateCountInUIState();
        }

        function saveRepeatSetting() {
            isRepeatEnabled = repeatCheckbox.checked;
            localStorage.setItem('mikeMetronomeRepeat', isRepeatEnabled);
        }

        function loadSettings() {
            if(localStorage.getItem('mikeMetronomeBasicBpm')) bpmInput.value = localStorage.getItem('mikeMetronomeBasicBpm');
            if(localStorage.getItem('mikeMetronomeBasicCount')) beatCountInput.value = localStorage.getItem('mikeMetronomeBasicCount');
            if(localStorage.getItem('mikeMetronomeBasicValue')) beatValueInput.value = localStorage.getItem('mikeMetronomeBasicValue');
            
            if(localStorage.getItem('mikeMetronomeRepeat') === 'true') {
                isRepeatEnabled = true;
                repeatCheckbox.checked = true;
            }
            
            // Load Sound Setting
            const storedSound = localStorage.getItem('mikeMetronomeSoundType');
            if (storedSound) {
                currentSoundType = storedSound;
            }
            // Update Radio Buttons visually
            const radioBtn = document.querySelector(`input[name="soundType"][value="${currentSoundType}"]`);
            if(radioBtn) radioBtn.checked = true;

            const savedCI = localStorage.getItem('mikeMetronomeCountIn');
            if(savedCI) {
                try { countInSettings = JSON.parse(savedCI); } catch(e) {}
            }
            if(!countInSettings.value) countInSettings.value = 4;
            if(!countInSettings.accents || countInSettings.accents.length !== countInSettings.beats) {
                countInSettings.accents = generateDefaultAccents(countInSettings.beats);
            }

            const savedSeq = localStorage.getItem('mikeMetronomeSequence');
            if(savedSeq) {
                try {
                    sequence = JSON.parse(savedSeq);
                    sequence.forEach(step => {
                        if(!step.accents || step.accents.length !== step.beats) {
                            step.accents = generateDefaultAccents(step.beats);
                        }
                        if(step.name === undefined) step.name = "";
                    });
                } catch(e) {}
            }
            
            const savedSongsStore = localStorage.getItem('mikeMetronomeSavedSongs');
            if(savedSongsStore) {
                try { savedSequences = JSON.parse(savedSongsStore); } catch(e) { savedSequences = []; }
            }
        }

        function generateDefaultAccents(count) {
            let arr = [];
            for(let i=0; i<count; i++) {
                if(i===0) arr.push(2); 
                else if(count >= 4 && i === Math.floor(count/2)) arr.push(1); 
                else arr.push(0); 
            }
            return arr;
        }
        
        // --- SAVED SEQUENCES LOGIC ---
        function resetSequence() {
            if(confirm("Start a new empty sequence? Unsaved changes will be lost.")) {
                sequence = [{ name: "", bpm: 100, beats: 4, value: 4, bars: 4, accents: [2,0,0,0] }];
                countInSettings = { enabled: false, bpm: 100, beats: 4, value: 4, bars: 1, accents: [2,0,0,0] };
                saveSequence();
                saveCountIn();
                renderStepList();
                initCountInUI();
            }
        }

        function saveCurrentSequence() {
            const name = prompt("Enter a name for this sequence:");
            if(name && name.trim() !== "") {
                const newSong = {
                    id: Date.now(),
                    name: name.trim(),
                    sequence: JSON.parse(JSON.stringify(sequence)),
                    countIn: JSON.parse(JSON.stringify(countInSettings))
                };
                savedSequences.push(newSong);
                localStorage.setItem('mikeMetronomeSavedSongs', JSON.stringify(savedSequences));
                renderSavedSongsMenu();
                
                const acc = document.getElementsByClassName("accordion-btn");
                // Open saved songs (index 0) if not open
                if(acc[0] && !acc[0].classList.contains("active")) {
                   acc[0].click(); 
                }
                toggleMenu(); 
            }
        }
        
        function loadSavedSequence(id) {
            const song = savedSequences.find(s => s.id === id);
            if(song) {
                if(confirm(`Load "${song.name}"? This will replace your current sequence.`)) {
                    sequence = JSON.parse(JSON.stringify(song.sequence));
                    countInSettings = JSON.parse(JSON.stringify(song.countIn));
                    
                    saveSequence();
                    saveCountIn();
                    
                    renderStepList();
                    initCountInUI();
                    
                    toggleMenu();
                    switchTab('advanced');
                }
            }
        }
        
        function deleteSavedSong(id, event) {
            event.stopPropagation(); 
            if(confirm("Are you sure you want to delete this song?")) {
                savedSequences = savedSequences.filter(s => s.id !== id);
                localStorage.setItem('mikeMetronomeSavedSongs', JSON.stringify(savedSequences));
                renderSavedSongsMenu();
            }
        }
        
        function renderSavedSongsMenu() {
            savedSongsList.innerHTML = "";
            if(savedSequences.length === 0) {
                savedSongsList.innerHTML = '<p style="font-size: 12px; color:#888; text-align:center; padding: 10px 0;">No songs saved yet</p>';
                return;
            }
            
            savedSequences.forEach(song => {
                const div = document.createElement('div');
                div.className = 'saved-song-item';
                div.onclick = () => loadSavedSequence(song.id);
                div.innerHTML = `
                    <span class="saved-song-name">${song.name}</span>
                    <button class="delete-song-btn" onclick="deleteSavedSong(${song.id}, event)">√ó</button>
                `;
                savedSongsList.appendChild(div);
            });
            
            // Recalculate if open
            const acc = document.getElementsByClassName("accordion-btn");
            // Assuming saved songs is index 0
            if (acc[0] && acc[0].classList.contains("active")) {
                const panel = acc[0].nextElementSibling;
                panel.style.maxHeight = panel.scrollHeight + "px";
            }
        }

        // --- NAVIGATION LOGIC ---
        function switchTab(mode) {
            stopMetronome(); 
            currentMode = mode;
            
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));

            if (mode === 'basic') {
                basicPanel.classList.add('active');
                document.querySelector('button[onclick="switchTab(\'basic\')"]').classList.add('active');
            } else {
                advPanel.classList.add('active');
                document.querySelector('button[onclick="switchTab(\'advanced\')"]').classList.add('active');
            }
        }

        // --- UI LOGIC: COUNT IN ---
        function initCountInUI() {
            countInCheck.checked = countInSettings.enabled;
            ciBpm.value = countInSettings.bpm;
            ciBeats.value = countInSettings.beats;
            ciValue.value = countInSettings.value || 4;
            ciBars.value = countInSettings.bars;
            updateCountInDots();
            updateCountInUIState();
        }

        function toggleCountIn() { saveCountIn(); }

        function updateCountInUIState() {
            if(countInSettings.enabled) {
                countInBox.classList.remove('disabled');
                document.getElementById('countInControls').style.opacity = "1";
                document.getElementById('countInControls').style.pointerEvents = "auto";
            } else {
                countInBox.classList.add('disabled');
                document.getElementById('countInControls').style.opacity = "0.3";
                document.getElementById('countInControls').style.pointerEvents = "none";
            }
        }

        function updateCountInDots() {
            const beats = parseInt(ciBeats.value);
            const oldAccents = countInSettings.accents;
            let newAccents = [];
            for(let i=0; i<beats; i++) {
                if(i < oldAccents.length) newAccents.push(oldAccents[i]);
                else if(i===0) newAccents.push(2);
                else newAccents.push(0);
            }
            countInSettings.accents = newAccents;

            ciAccentsContainer.innerHTML = '';
            countInSettings.accents.forEach((level, i) => {
                const d = document.createElement('div');
                d.className = 'mini-dot';
                d.dataset.level = level;
                d.onclick = () => {
                    countInSettings.accents[i] = (countInSettings.accents[i] + 1) % 3;
                    d.dataset.level = countInSettings.accents[i];
                    localStorage.setItem('mikeMetronomeCountIn', JSON.stringify(countInSettings));
                };
                ciAccentsContainer.appendChild(d);
            });
        }

        // --- UI LOGIC: BASIC MODE ---
        function updateBasicDots(count) {
            count = parseInt(count);
            let oldAccents = [...basicAccents];
            basicAccents = [];
            for (let i = 0; i < count; i++) {
                let level = 0;
                if (i < oldAccents.length) level = oldAccents[i];
                else if (i === 0) level = 2; 
                basicAccents.push(level);
            }
            renderBasicDotsUI();
            saveBasicSettings();
        }

        function renderBasicDotsUI() {
            beatContainer.innerHTML = '';
            basicAccents.forEach((level, i) => {
                const dot = document.createElement('div');
                dot.className = 'beat-dot';
                dot.dataset.index = i;
                dot.dataset.level = level;
                dot.addEventListener('click', () => {
                    let newLevel = (parseInt(dot.dataset.level) + 1) % 3;
                    dot.dataset.level = newLevel;
                    basicAccents[i] = newLevel;
                    saveBasicSettings();
                });
                beatContainer.appendChild(dot);
            });
        }

        // --- UI LOGIC: ADVANCED STEPS ---
        function renderStepList() {
            const container = document.getElementById('stepListContainer');
            container.innerHTML = '';
            
            sequence.forEach((step, index) => {
                const el = document.createElement('div');
                el.className = 'step-item';
                el.id = `step-row-${index}`;
                
                if(!step.accents) step.accents = generateDefaultAccents(step.beats);
                // Ensure name exists
                if(step.name === undefined) step.name = "";
                
                el.innerHTML = `
                    <div class="step-header">
                        <input type="text" class="step-name-input" value="${step.name}" placeholder="Step ${index + 1}" onchange="updateStep(${index}, 'name', this.value)">
                        <button class="delete-btn" onclick="removeStep(${index})">√ó</button>
                    </div>
                    <div class="step-inputs">
                        <div class="step-input-group">
                            <label>BPM</label>
                            <input type="number" value="${step.bpm}" onchange="updateStep(${index}, 'bpm', this.value)">
                        </div>
                        <div class="step-input-group">
                            <label>Sig.</label>
                            <div style="display:flex; gap:2px;">
                                <input type="number" value="${step.beats}" onchange="updateStep(${index}, 'beats', this.value)">
                                <select onchange="updateStep(${index}, 'value', this.value)">
                                    <option value="4" ${step.value==4?'selected':''}>/4</option>
                                    <option value="8" ${step.value==8?'selected':''}>/8</option>
                                    <option value="2" ${step.value==2?'selected':''}>/2</option>
                                </select>
                            </div>
                        </div>
                        <div class="step-input-group">
                            <label>Bars</label>
                            <input type="number" value="${step.bars}" onchange="updateStep(${index}, 'bars', this.value)">
                        </div>
                    </div>
                    <label style="font-size:10px; color:#666;">Accents:</label>
                    <div class="step-accents" id="step-accents-${index}"></div>
                `;
                container.appendChild(el);

                const dotsContainer = document.getElementById(`step-accents-${index}`);
                step.accents.forEach((level, beatIdx) => {
                    const d = document.createElement('div');
                    d.className = 'mini-dot';
                    d.dataset.level = level;
                    d.onclick = () => toggleStepAccent(index, beatIdx);
                    dotsContainer.appendChild(d);
                });
            });
        }

        function toggleStepAccent(stepIdx, beatIdx) {
            let current = sequence[stepIdx].accents[beatIdx];
            sequence[stepIdx].accents[beatIdx] = (current + 1) % 3;
            renderStepList();
            saveSequence();
        }

        function addStep() {
            // NEW LOGIC: Inherit BPM from last step
            let newBpm = 100;
            if (sequence.length > 0) {
                newBpm = sequence[sequence.length - 1].bpm;
            }

            // ADDED EMPTY NAME PROPERTY
            sequence.push({ name: "", bpm: newBpm, beats: 4, value: 4, bars: 4, accents: [2,0,0,0] });
            renderStepList();
            saveSequence();
        }

        function removeStep(index) {
            sequence.splice(index, 1);
            renderStepList();
            saveSequence();
        }

        function updateStep(index, field, value) {
            if(field === 'name') {
                sequence[index][field] = value;
            } else {
                value = parseInt(value);
                sequence[index][field] = value;
            }
            
            if(field === 'beats') {
                const oldAccents = sequence[index].accents;
                let newAccents = [];
                for(let i=0; i<value; i++) {
                    if(i < oldAccents.length) newAccents.push(oldAccents[i]);
                    else if(i===0) newAccents.push(2);
                    else newAccents.push(0);
                }
                sequence[index].accents = newAccents;
                renderStepList(); 
            }
            saveSequence();
        }

        // --- AUDIO ENGINE ---
        function playSound(freq, time) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.connect(gain);
            gain.connect(audioContext.destination);

            const type = currentSoundType;
            
            // Map the input frequency (which comes from accents: 600, 1000, 1500) 
            // to our desired sound profiles

            if (type === 'wood') {
                // OPTION 2: WOOD / CLICK
                osc.type = 'triangle';
                
                // MAPPING: freq 1500->800, 1000->600, 600->400
                if (freq > 1000) osc.frequency.value = 800;      
                else if (freq > 800) osc.frequency.value = 600;  
                else osc.frequency.value = 400;                  

                // Very short envelope for percussive effect
                gain.gain.setValueAtTime(1.0, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                
                osc.start(time);
                osc.stop(time + 0.05);

            } else if (type === 'soft') {
                // OPTION 3: SOFT / SINE
                osc.type = 'sine';
                
                // MAPPING: freq 1500->880, 1000->440, 600->220
                if (freq > 1000) osc.frequency.value = 880;      
                else if (freq > 800) osc.frequency.value = 440;  
                else osc.frequency.value = 220;                  

                // Softer attack and release
                gain.gain.setValueAtTime(0.8, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                
                osc.start(time);
                osc.stop(time + 0.15);

            } else {
                // OPTION 1: SHARP (DEFAULT) - Original Logic
                osc.type = 'square'; 
                osc.frequency.value = freq;
                
                if(freq > 1000) gain.gain.value = 0.8; 
                else if (freq > 800) gain.gain.value = 0.4; 
                else gain.gain.value = 0.2; 

                osc.start(time);
                osc.stop(time + 0.05); 
            }
        }

        function scheduler() {
            const lookahead = 0.1; 
            while (nextNoteTime < audioContext.currentTime + lookahead) {
                if(!isRunning) return; 

                if (currentMode === 'basic') {
                    scheduleBasic();
                } else {
                    scheduleAdvanced();
                }
            }
            if (isRunning) timerID = setTimeout(scheduler, 25);
        }

        function scheduleBasic() {
            const level = basicAccents[currentBeatIndex];
            
            // Calculate base frequencies (Logic for Sharp sound)
            let freq = 600; 
            if (level === 2) freq = 1500;
            if (level === 1) freq = 1000;
            
            playSound(freq, nextNoteTime);

            const beatIndexForVisual = currentBeatIndex;
            const timeForVisual = (nextNoteTime - audioContext.currentTime) * 1000;
            setTimeout(() => {
                document.querySelectorAll('.beat-dot').forEach(d => d.classList.remove('playing'));
                const dot = beatContainer.children[beatIndexForVisual];
                if(dot) dot.classList.add('playing');
            }, timeForVisual);

            const bpm = parseFloat(bpmInput.value);
            const den = parseInt(beatValueInput.value);
            const secondsPerBeat = 60.0 / (bpm * (den / 4));
            
            nextNoteTime += secondsPerBeat;
            
            currentBeatIndex++;
            if (currentBeatIndex >= basicAccents.length) currentBeatIndex = 0;
        }

        function scheduleAdvanced() {
            const currentBeatVis = advBeatCounter; 

            // --- PHASE 0: COUNT IN ---
            if (playPhase === 0) {
                const step = countInSettings;
                let level = step.accents[advBeatCounter];
                
                let freq = 600;
                if(level === 2) freq = 1500;
                if(level === 1) freq = 1000;
                
                playSound(freq, nextNoteTime);

                const curBar = advBarCounter;
                const timeForVisual = (nextNoteTime - audioContext.currentTime) * 1000;
                
                setTimeout(() => {
                    document.querySelectorAll('.mini-dot').forEach(d => d.classList.remove('playing'));

                    countInBox.classList.add('active');
                    document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
                    
                    advStepName.textContent = `Count-in`;
                    advBarCountEl.textContent = `Bar ${curBar} / ${step.bars}`;
                    
                    if(ciAccentsContainer.children[currentBeatVis]) {
                        ciAccentsContainer.children[currentBeatVis].classList.add('playing');
                    }

                    if(level === 2) {
                          advBarCountEl.style.color = "#03dac6";
                          setTimeout(()=>advBarCountEl.style.color="#fff", 100);
                    }
                }, timeForVisual);

                const secondsPerBeat = 60.0 / (step.bpm * (step.value / 4)); 
                nextNoteTime += secondsPerBeat;

                advBeatCounter++;
                if(advBeatCounter >= step.beats) {
                    advBeatCounter = 0;
                    advBarCounter++;
                    if(advBarCounter > step.bars) {
                        playPhase = 1; 
                        currentStepIndex = 0;
                        advBarCounter = 1;
                        advBeatCounter = 0;
                    }
                }
                return;
            }

            // --- PHASE 1: SEQUENCE ---
            if (currentStepIndex >= sequence.length) {
                if(isRepeatEnabled) {
                    playPhase = 1;
                    currentStepIndex = 0;
                    advBarCounter = 1;
                    advBeatCounter = 0;
                } else {
                    stopMetronome();
                    return;
                }
            }

            if(sequence.length === 0) { stopMetronome(); return; }

            const step = sequence[currentStepIndex];
            
            let accentLevel = 0;
            if(step.accents && step.accents[advBeatCounter] !== undefined) {
                accentLevel = step.accents[advBeatCounter];
            }
            
            let freq = 600;
            if (accentLevel === 2) freq = 1500;
            if (accentLevel === 1) freq = 1000;

            playSound(freq, nextNoteTime);

            const currentStepIdxVis = currentStepIndex;
            const currentBarVis = advBarCounter;
            const timeForVisual = (nextNoteTime - audioContext.currentTime) * 1000;
            
            setTimeout(() => {
                document.querySelectorAll('.mini-dot').forEach(d => d.classList.remove('playing'));

                countInBox.classList.remove('active');
                document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
                
                const activeRow = document.getElementById(`step-row-${currentStepIdxVis}`);
                if(activeRow) {
                    activeRow.classList.add('active');
                    activeRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                let displayName = step.name ? `${step.name} (Step ${currentStepIdxVis + 1})` : `Step ${currentStepIdxVis + 1} / ${sequence.length}`;
                advStepName.textContent = displayName;
                advBarCountEl.textContent = `Bar ${currentBarVis} / ${step.bars}`;
                
                const stepDotsContainer = document.getElementById(`step-accents-${currentStepIdxVis}`);
                if(stepDotsContainer && stepDotsContainer.children[currentBeatVis]) {
                    stepDotsContainer.children[currentBeatVis].classList.add('playing');
                }

                if (accentLevel === 2) {
                    advBarCountEl.style.color = "#03dac6";
                    setTimeout(()=>advBarCountEl.style.color="#fff", 100);
                }
            }, timeForVisual);

            const secondsPerBeat = 60.0 / (step.bpm * (step.value / 4));
            nextNoteTime += secondsPerBeat;

            advBeatCounter++;
            if (advBeatCounter >= step.beats) {
                advBeatCounter = 0;
                advBarCounter++;
                if (advBarCounter > step.bars) {
                    currentStepIndex++;
                    advBarCounter = 1;
                    advBeatCounter = 0;
                }
            }
        }

        // --- START / STOP ---
        function stopMetronome() {
            clearTimeout(timerID);
            isRunning = false;
            
            mainBtn.textContent = "START";
            mainBtn.classList.remove('stop');
            document.querySelectorAll('.beat-dot').forEach(d => d.classList.remove('playing'));
            document.querySelectorAll('.mini-dot').forEach(d => d.classList.remove('playing'));
            
            advStatus.style.display = 'none';
            document.querySelectorAll('.step-item').forEach(el => el.classList.remove('active'));
            countInBox.classList.remove('active');

            releaseWakeLock();
        }

        mainBtn.addEventListener('click', () => {
            if (isRunning) {
                stopMetronome();
            } else {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (audioContext.state === 'suspended') audioContext.resume();

                currentBeatIndex = 0;
                
                if(currentMode === 'advanced') {
                    advStatus.style.display = 'block';
                    if(countInSettings.enabled) {
                        playPhase = 0; 
                    } else {
                        playPhase = 1; 
                    }
                    currentStepIndex = 0;
                    advBarCounter = 1;
                    advBeatCounter = 0;
                }

                nextNoteTime = audioContext.currentTime + 0.05;
                isRunning = true;
                mainBtn.textContent = "STOP";
                mainBtn.classList.add('stop');

                requestWakeLock();
                scheduler();
            }
        });

    </script>
    <script>
    if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
            navigator.serviceWorker.register("./sw.js").then((registration) => {
                console.log("Service Worker geregistreerd met scope:", registration.scope);

                if (registration.waiting) {
                    notifyUserOfUpdate(registration.waiting);
                }

                registration.addEventListener('updatefound', () => {
                    const newWorker = registration.installing;
                    newWorker.addEventListener('statechange', () => {
                        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                            notifyUserOfUpdate(newWorker);
                        }
                    });
                });
            }).catch((err) => {
                console.log("Service Worker registratie mislukt:", err);
            });
        });

        function notifyUserOfUpdate(worker) {
            if (confirm("A new version of the Mike's Metronome app is available. Do you want to reload now?")) {
                worker.postMessage({ action: 'skipWaiting' });
            }
        }

        let refreshing;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (refreshing) return;
            window.location.reload();
            refreshing = true;
        });
    }
</script>
</body>
</html>

